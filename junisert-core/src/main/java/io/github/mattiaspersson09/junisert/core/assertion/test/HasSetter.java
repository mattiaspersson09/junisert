/*
 * Copyright (c) 2025-2025 Mattias Persson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.mattiaspersson09.junisert.core.assertion.test;

import io.github.mattiaspersson09.junisert.api.assertion.UnitAssertionError;
import io.github.mattiaspersson09.junisert.api.internal.service.ValueService;
import io.github.mattiaspersson09.junisert.api.value.UnsupportedTypeError;
import io.github.mattiaspersson09.junisert.api.value.Value;
import io.github.mattiaspersson09.junisert.common.logging.Logger;
import io.github.mattiaspersson09.junisert.core.reflection.Field;
import io.github.mattiaspersson09.junisert.core.reflection.Method;
import io.github.mattiaspersson09.junisert.core.reflection.Unit;

public class HasSetter implements UnitTest {
    private static final Logger LOGGER = Logger.getLogger(HasSetter.class);

    private final ValueService valueService;

    public HasSetter(ValueService valueService) {
        this.valueService = valueService;
    }

    @Override
    public boolean test(Unit unit) {
        for (Field field : unit.getFields()) {
            // Ignores autogenerated synthetic fields (i.e. JaCoCo fields for data and such)
            if (field.isSynthetic()) {
                continue;
            }

            if (field.getSetters().isEmpty()) {
                throw new UnitAssertionError(unit.getName() + " was expected to have setter "
                        + "for field '" + field.getName() + "', "
                        + "but none was found");
            }

            LOGGER.info("Checking field: " + unit.getName() + "." + field.getName());

            for (Method method : field.getSetters()) {
                // Ignores autogenerated synthetic methods (i.e. JaCoCo methods and such)
                if (method.isSynthetic()) {
                    continue;
                }

                Value<?> argument = valueService.findValue(field.getType())
                        .orElseThrow(() -> new UnsupportedTypeError(field.getType()));
                System.out.println(argument);
                Object instance = unit.createInstance()
                        .orElseThrow(() -> new UnitAssertionError(""));

                if (!field.setValue(instance, argument.get())) {
                    throw new RuntimeException();
                }

                Object valueBefore = field.getValueOrElse(instance, argument.asEmpty());
                Object result = Invocation.target(method, argument.asEmpty())
                        .fromInstance(instance)
                        .shouldResultIn(() -> !valueBefore.equals(field.getValueOrElse(instance, valueBefore)))
                        .invoke();
            }
        }

        return false;
    }

//    private boolean isSettingValueForFieldInPojo(Method setter, Field field) {
//        try {
//            LOGGER.info("Field is primitive: " + field.type().isPrimitive());
//            Object pojoObject = objectSupplier.get();
//            field.setValue(pojoObject, ValueGenerator.generateFromType(field.type()).getValue());
//            Object fieldValueBefore = field.getValue(pojoObject);
//
//            LOGGER.debug("Value before setter: {}", fieldValueBefore);
//
//            Parameter[] params = setter.getParameters();
//            List<Object> setterParameters = new ArrayList<>();
//
//            for (Parameter p : params) {
//                Type parameterType = p.getType();
//                Object object = ValueGenerator.generateFromType(parameterType).getNonValue();
//                LOGGER.debug("Value to inject into setter: {}", object.toString());
//                setterParameters.add(object);
//            }
//
//            LOGGER.debug(
//                    "{}({}) -> invoking {}({})",
//                    setter.name(),
//                    setter.getParameters(),
//                    setter.name(),
//                    setterParameters);
//            setter.invoke(pojoObject, setterParameters.toArray());
//            Object fieldValueAfter = field.getValue(pojoObject);
//
//            if (fieldValueAfter.equals(fieldValueBefore)) {
//                LOGGER.debug("Value not changed after invoking setter: {}", setter.name());
//                throw new SetterAssertionError("Invoking setter did not set value for field");
//            }
//        } catch (IllegalAccessException | InvocationTargetException e) {
//            throw new RuntimeException(e);
//        }

//        return true;
//    }
}
