/*
 * Copyright (c) 2025-2025 Mattias Persson
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.mattiaspersson09.junisert.core.assertion;

import io.github.mattiaspersson09.junisert.api.internal.service.ValueService;
import io.github.mattiaspersson09.junisert.core.reflection.Field;
import io.github.mattiaspersson09.junisert.core.reflection.Method;
import io.github.mattiaspersson09.junisert.core.reflection.Unit;

import java.util.function.Predicate;

public class HasSetter implements Predicate<Unit> {
//    private static final Logger LOGGER = Logger.getLogger(HasSetter.class);

    private final ValueService valueService;

    public HasSetter(ValueService valueService) {
        this.valueService = valueService;
    }

    @Override
    public boolean test(Unit unit) {
//        for (Field field : unit.getFields()) {
//            // Ignores autogenerated synthetic fields (i.e. JaCoCo fields for data and such)
//            if (field.isSynthetic()) {
//                continue;
//            }
//
//            boolean hasSetter = false;
//            LOGGER.info("Checking field: " + field.name());
//
//            for (Method method : unit.getMethods()) {
//                // Ignores autogenerated synthetic methods (i.e. JaCoCo methods and such)
//                if (method.isSynthetic()) {
//                    continue;
//                }
//
//                // Match
//                if (method.isSetterForField(field)) {
//                    LOGGER.info(unit.name() + " has setter '" + method.name() + "' for field '" + field.name() + "'");
        ////                    field.setSetter(method);
//
//                    if (isSettingValueForFieldInPojo(method, field)) {
//                        hasSetter = true;
//                        break;
//                    }
//                }
//            }
//
//            if (!hasSetter) {
//                throw new SetterAssertionError(unit.name() + " is missing setter for field: " + field.name());
//            }
//        }

        return false;
    }

    private boolean isSettingValueForFieldInPojo(Method setter, Field field) {
//        try {
//            LOGGER.info("Field is primitive: " + field.type().isPrimitive());
//            Object pojoObject = objectSupplier.get();
//            field.setValue(pojoObject, ValueGenerator.generateFromType(field.type()).getValue());
//            Object fieldValueBefore = field.getValue(pojoObject);
//
//            LOGGER.debug("Value before setter: {}", fieldValueBefore);
//
//            Parameter[] params = setter.getParameters();
//            List<Object> setterParameters = new ArrayList<>();
//
//            for (Parameter p : params) {
//                Type parameterType = p.getType();
//                Object object = ValueGenerator.generateFromType(parameterType).getNonValue();
//                LOGGER.debug("Value to inject into setter: {}", object.toString());
//                setterParameters.add(object);
//            }
//
//            LOGGER.debug(
//                    "{}({}) -> invoking {}({})",
//                    setter.name(),
//                    setter.getParameters(),
//                    setter.name(),
//                    setterParameters);
//            setter.invoke(pojoObject, setterParameters.toArray());
//            Object fieldValueAfter = field.getValue(pojoObject);
//
//            if (fieldValueAfter.equals(fieldValueBefore)) {
//                LOGGER.debug("Value not changed after invoking setter: {}", setter.name());
//                throw new SetterAssertionError("Invoking setter did not set value for field");
//            }
//        } catch (IllegalAccessException | InvocationTargetException e) {
//            throw new RuntimeException(e);
//        }

        return true;
    }
}
